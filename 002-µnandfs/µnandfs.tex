\documentclass[letterpaper,10pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage[justification=centering,font=small,labelfont=bf]{caption}
\usepackage{fancyhdr}
\usepackage{fontspec}
\defaultfontfeatures{Ligatures=TeX}
\usepackage{xeCJK}
\usepackage[backend=biber,
date=iso,
seconds=true,
style=numeric,
bibencoding=utf8,
]{biblatex}
\addbibresource{\jobname.bib}
\newenvironment{denseitemize}{
  \begin{itemize}
      \setlength{\itemsep}{0pt}
}{
  \end{itemize}
}

\pagestyle{fancy}
\rhead{DSSCAW Technical Report \#002}

\title{µnandfs:\\
A NAND Blobstore for Memory-Starved Platforms\thanks{
 \href{https://www.dsscaw.com/}{Dirty South Supercomputing} on behalf
 of \href{https://www.vakaros.com/}{Vakaros} of Atlanta, GA.
}\\
}
\author{Nick Black, Consulting Scientist\\
\texttt{nickblack@linux.com}
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\maketitle
\thispagestyle{fancy}
\date{}
\begin{abstract}
I was tasked with designing and implementing a persistent associative array
mapping names to arbitrary data---i.e. a single-directory filesystem, often
called a \textit{blobstore}---using the Nordic Semiconductor nRF52840 and two
Winbond W25N01GV gigabit SLC NAND chips. The contract also required necessary
QSPI drivers. The requirements permitted 4KB of RAM, permitted 4KB of RAM,
allowed no use of other persistent storage, and mandated a fully asynchronous
API running on ``bare metal'' (no OS, realtime or otherwise). I detail my
resulting deliverable, µnandfs, and demonstrate its generally performant
and robust fulfillment of these specs. I also describe its pathological worst
case behaviors.
\end{abstract}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction}
The client's initial request was simply ``a filesystem on the nRF52840 using
two W25N01GV NANDs, plus any necessary drivers, plus an entirely asynchronous
C++ API, in as little RAM as possible''. Refinement of these requirements
determined that:
\begin{denseitemize}
\item Most files would be on the order of 1KB, with a few files
       on the order of tens of megabytes. These larger files would grow
       over time, via substantial (page-sized) appends.
\item It was not thought necessary to have directories, nor sym- or hardlinks,
       but it must be possible to remove files, reclaiming both their space and
       name.
\item It must be possible to have multiple files open at once, but it is not
       necessary that a single file support multiple open handles.
\item No more than 4KB of RAM was to be consumed, and ideally persistent use
       would be not more than 2KB. Callers, however, could be required to supply
       an additional 2KB for the duration of their call.
\item Wear-leveling must be as close to uniform as possible. Ideally, no block
       would be erased two times more than any other block.
\end{denseitemize}

The nRF52840\parencite{nrf52840} SoC pairs an ARM Cortex-M4F with 1MB of
NOR flash and 256KB of RAM, along with a wealth of interconnection
capabilities. This storage is shared with the ``S140
SoftDevice''\parencite{s140}, a closed-source BlueTooth stack, which consumes
slightly more than 100KB of RAM and significant flash.
Two Winbond W25N01GV\parencite{winbond}
128MB NANDs, each capable of QSPI at up to 104MHz, were added to the PCB.
One QSPI and three SPI masters are available, each clocked at 32MHz (ignoring
overhead, 32MHz QSPI moves 16MB/s, and SPI 4MB/s). Nordic's nRF5 SDK\parencite{nrf52sdk}
version 15.3.0 was linked into our binary, and the DUT was probed via 10-pin
J-Link\parencite{segger} connection from an nRF52-DK\parencite{nrf52dk}.

\section{Details of NAND flash}

NAND flash---typically packaged as a collection of chips, and often managed via
an on-board controller---makes up the majority of modern solid state drives,
flash drives, and memory cards. It is cheaper and denser than NOR flash\footnote{This goes double for EEPROMs.},
and faster than spinning disk\footnote{NAND is denser than some hard disk
technologies, but not all.}, but typically less reliable than either, and there
are severe constraints on how it can be used. A chip of NAND flash is divided
into some number of blocks, which are themselves divided into pages. Erasing
a block changes all bits within to 1s\footnote{Nothing about the NAND memory
cell itself---floating-gate MOSFETs connected in series---requires large-scale
operations. Larger blocks mean faster operations (per bit), cheaper chips, and
less power draw. They also intensify errors, and of course reduce flexibility.}.
Data can be written a page at a time within a block, but usually only in
ascending page order. Data can be read a page at a time from anywhere within
the block, but reading a page too many times can upset data in an adjacent
page (a ``read disturb'').

SLC NAND flash stores one bit per
cell, and blocks can be erased on the order of $100\,000$ times. MLC and TLC
variants encode more bits per cell, and can be reliably erased far fewer times. They
also tend to be slower, and to require more ECC bits per data bit.

\subsection{Details of the Winbond W25N01GV}

\section{Future work}
It is desirable to encode large files more efficiently. Currently, a file of
the maximum $2^{24}-1$ bytes requires 8192 inodes, requiring (in the best case)
530 pages of metadata, and attendant reads. When all of a zone is a single
blob, some different scheme ought be employed to encode this fact.
Unfortunately, it's unlikely that such a write could ever be performed as a
single ExtendBlob() operation, due to the RAM requirements of such a buffer.

It is not currently possible to use the two chips in parallel as a single,
unified blobstore. If placed on distinct SPI masters, they can be used in
parallel as two blobstores, or as a mirrored set. In any configuration---even
a single SPI master---they can be combined as a linear device. A unified
2Gbit namespace accessible at 2x34MHz, however, is not yet possible. Mirrored
sets could be implemented via ``superblocks''\parencite{superblocks} for
maximum performance, requiring only a single SPI master.

An ECC failure reading a metadata page currently results in the blobstore being
brought offline. Given that ECC failures can often be recognized immediately
after programming, metapages should probably be read back following write,
remapped using the BBM LUT, and written anew. In any case, a more graceful
recovery seems desirable.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\printbibliography
\end{document}
