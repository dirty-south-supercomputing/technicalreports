\section{Using ncplanes}
\label{sec:planes}
\label{ncplane}
As mentioned in Chapter~\ref{sec:fullscreen}, \texttt{ncplane}s (henceforth
simply planes) are the fundamental drawing surface of Notcurses. A Notcurses
instance contains a z-axis on which planes are totally ordered\footnote{Future
releases of Notcurses might relax this to a partial ordering, allowing
multiple ncplanes to partition a logical level. See
\url{https://github.com/dankamongmen/notcurses/issues/184}.}. In addition, it
always contains at least one plane, the \textit{standard plane}. This plane's
origin is always defined to be the rendering area's origin. It is always
exactly as large as the rendering area, and it cannot be destroyed.

Chapter \ref{sec:notcursesfuncs} introduced one function that creates a new
plane: \texttt{ncplane\_new()}. In addition, there is \texttt{ncplane\_aligned()}.

\begin{listing}[!htbp]
\begin{minted}{C}
// Create a new ncplane at the specified 'yoff', of the specified 'rows' and 'cols'. Align this plane
// according to 'align' relative to 'n'.
struct ncplane* ncplane_aligned(struct ncplane* n, int rows, int cols, int yoff, ncalign_e align, void* opaque);
\end{minted}
\caption{Creating a new plane aligned relative to another.}
\end{listing}

A plane is defined by:
\begin{denseitemize}
\item{A packed ``framebuffer'' of \texttt{cell} structures. Cells are discussed
    in detail in~\ref{sec:cells}; it is enough now to know that each has an
    EGC, a set of attributes, and a fore- and background color.}
\item{A ``base cell'', rendered for any cell with a null EGC.}
\item{A cursor position relative to the plane's origin.}
\item{The plane's position relative to the visible area's origin.}
\item{A two-dimensional size.}
\item{An ``egcpool'' providing backing storage for the framebuffer.}
\item{An opaque pointer, controlled by the application.}
\item{A current set of attributes and colors.}
\item{A pointer to the plane below this one, or \texttt{NULL} for the bottommost plane.}
\end{denseitemize}

However a plane is created---including the standard plane---it is initialized
in the same way. All cells--both the base cell and those of the
framebuffer---are zeroed out. A zeroed cell has the null glyph (UTF-8
value ``00''), no attributes, and the default foreground and background color
(default colors are always opaque). Note that planes are thus by default
glyph-transparent but color-opaque. The cursor is placed at the origin. The
plane's current attributes and channels are likewise zeroed out. The plane is
pushed onto the top of the z-axis and assigned an initialized egcpool
(see~\ref{sec:egcpools}).

A plane can be duplicated with \texttt{ncplane\_dup()}. This will create a new
plane of the same geometry at the top of the z-axis. It will then have all
other properties duplicated, using its own egcpool.
\begin{listing}[!htbp]
\begin{minted}{C}
// Duplicate an existing ncplane. The new plane will have the same geometry, will duplicate all content, and
// will start with the same rendering state. The new plane will be immediately above the old one on the z axis.
struct ncplane* ncplane_dup(struct ncplane* n, void* opaque);
\end{minted}
\caption{Duplicating a plane.}
\end{listing}

Besides the default plane, planes may occupy any positive size (both the number
of rows and columns must be greater than zero), and have their origins any
integer offset from the visual origin. It is possible for a plane to be a
superset of the visual area, a subset, to exactly match the visual area, to
partially overlap it, or even to be entirely off-screen. A plane can be
moved to any coordinate, but the plane's cursor cannot be moved off the plane.

Any plane save the standard plane may be destroyed with \texttt{ncplane\_destroy()}.
All planes save the standard plane may be destroyed in one fell swoop with
\texttt{notcurses\_drop\_planes()}.
\begin{listing}[!htbp]
\begin{minted}{C}
// Destroy the specified ncplane. None of its contents will be visible after the next
// call to notcurses_render(). It is an error to attempt to destroy the standard plane.
int ncplane_destroy(struct ncplane* ncp);

// Destroy all ncplanes other than the standard plane.
void notcurses_drop_planes(struct notcurses* nc);
\end{minted}
\caption{Destroying planes.}
\end{listing}

\subsection{Moving and resizing planes}
Even the standard plane can be reordered along the z-axis. \texttt{ncplane\_move\_top()}
and \texttt{ncplane\_move\_bottom()} are absolute, moving the specified plane
to the top or bottom of the z-axis, respectively. \texttt{ncplane\_move\_above()}
and \texttt{ncplane\_move\_below()} are relative, moving the plane immediately
above or below another one. It is an error to try and move a plane below or above itself,
or above or below \texttt{NULL}. Likewise, an error will be returned if the relative
plane does not exist on the z-axis.
\begin{listing}[!htbp]
\begin{minted}{C}
// Splice ncplane 'n' out of the z-buffer, and reinsert it at the top or bottom.
int ncplane_move_top(struct ncplane* n);
int ncplane_move_bottom(struct ncplane* n);

// Splice ncplane 'n' out of the z-buffer, and reinsert it above 'above'.
int ncplane_move_above_unsafe(struct ncplane* restrict n, struct ncplane* restrict above);

static inline int
ncplane_move_above(struct ncplane* n, struct ncplane* above){
  if(n == above){
    return -1;
  }
  return ncplane_move_above_unsafe(n, above);
}

// Splice ncplane 'n' out of the z-buffer, and reinsert it below 'below'.
int ncplane_move_below_unsafe(struct ncplane* restrict n, struct ncplane* restrict below);

static inline int
ncplane_move_below(struct ncplane* n, struct ncplane* below){
  if(n == below){
    return -1;
  }
  return ncplane_move_below_unsafe(n, below);
}

// Return the plane above this one, or NULL if this is at the top.
struct ncplane* ncplane_below(struct ncplane* n);
\end{minted}
\caption{Moving planes on the z axis.}
\end{listing}

All planes other than the standard plane can be moved in the x- and y-dimensions.
\begin{listing}[!htbp]
\begin{minted}{C}
// Move this plane relative to the standard plane. It is an error to attempt to move the standard plane.
int ncplane_move_yx(struct ncplane* n, int y, int x);
\end{minted}
\caption{Moving planes on the x and y axis.}
\end{listing}

\textbf{FIXME ncplane\_resize(), \_rotate()...}

Sometimes it is useful to translate coordinates between planes, or between the
visible area and planes (this latter is particularly useful when interpreting
mouse clicks; see Chapter~\ref{sec:input}).
\begin{listing}[!htbp]
\begin{minted}{C}
// provided a coordinate relative to the origin of 'src', map it to the same absolute coordinate
// relative to thte origin of 'dst'. either or both of 'y' and 'x' may be NULL.
void ncplane_translate(const struct ncplane* src, const struct ncplane* dst, int* restrict y, int* restrict x);

// Fed absolute 'y'/'x' coordinates, determine whether that coordinate is within the ncplane 'n'. If not, return false.
// If so, return true. Either way, translate the absolute coordinates relative to 'n'. If the point is not within 'n',
// these coordinates will not be within the dimensions of the plane.
bool ncplane_translate_abs(const struct ncplane* n, int* restrict y, int* restrict x);
\end{minted}
\caption{Translating coordinates between planes.}
\end{listing}

Just as each cell has a set of attributes and channels, the plane itself has
an active attribute set and active channels. These can be freely manipulated
using the API of Listings~\ref{listing:planeraw}, \ref{listing:planefg}, \ref{listing:planebg}, and
\ref{listing:planeattr}.

\begin{listing}[!htbp]
\begin{minted}{C}
// get the current channels or attribute word for ncplane 'n'.
uint64_t ncplane_channels(const struct ncplane* n);
uint32_t ncplane_attr(const struct ncplane* n);
\end{minted}
\caption{Accessing a plane's raw channels and attributes.}
\label{listing:planeraw}
\end{listing}

\begin{listing}[!htbp]
\begin{minted}{C}
// Extract the 32-bit working foreground channel from an ncplane.
static inline unsigned
ncplane_fchannel(const struct ncplane* nc){
  return channels_fchannel(ncplane_channels(nc));
}

// Extract 24 bits of working foreground RGB from an ncplane, shifted to LSBs.
static inline unsigned
ncplane_fg(const struct ncplane* nc){
  return channels_fg(ncplane_channels(nc));
}

// Extract 2 bits of foreground alpha from 'struct ncplane', shifted to LSBs.
static inline unsigned
ncplane_fg_alpha(const struct ncplane* nc){
  return channels_fg_alpha(ncplane_channels(nc));
}

// Extract 24 bits of foreground RGB from 'n', split into subcomponents.
static inline unsigned
ncplane_fg_rgb(const struct ncplane* n, unsigned* r, unsigned* g, unsigned* b){
  return channels_fg_rgb(ncplane_channels(n), r, g, b);
}

// Set the current fore/background color using RGB specifications. If the
// terminal does not support directly-specified 3x8b cells (24-bit "Direct
// Color", indicated by the "RGB" terminfo capability), the provided values
// will be interpreted in some lossy fashion. None of r, g, or b may exceed 255.
// "HP-like" terminals require setting foreground and background at the same
// time using "color pairs"; notcurses will manage color pairs transparently.
int ncplane_set_fg_rgb(struct ncplane* n, int r, int g, int b);

// Same, but clipped to [0..255].
void ncplane_set_fg_rgb_clipped(struct ncplane* n, int r, int g, int b);

// Same, but with rgb assembled into a channel (i.e. lower 24 bits).
int ncplane_set_fg(struct ncplane* n, unsigned channel);

// Use the default color for the foreground/background.
void ncplane_set_fg_default(struct ncplane* n);

// Set the ncplane's foreground palette index, set the foreground palette index
// bit, set it foreground-opaque, and clear the foreground default color bit.
int ncplane_set_fg_palindex(struct ncplane* n, int idx);

// Set the alpha parameters for ncplane 'n'.
int ncplane_set_fg_alpha(struct ncplane* n, int alpha);
\end{minted}
\caption{Manipulating a plane's active foreground channel.}
\label{listing:planefg}
\end{listing}

\begin{listing}[!htbp]
\begin{minted}{C}
// Extract the 32-bit working background channel from an ncplane.
static inline unsigned
ncplane_bchannel(const struct ncplane* nc){
  return channels_bchannel(ncplane_channels(nc));
}

// Extract 24 bits of working background RGB from an ncplane, shifted to LSBs.
static inline unsigned
ncplane_bg(const struct ncplane* nc){
  return channels_bg(ncplane_channels(nc));
}

// Extract 2 bits of background alpha from 'struct ncplane', shifted to LSBs.
static inline unsigned
ncplane_bg_alpha(const struct ncplane* nc){
  return channels_bg_alpha(ncplane_channels(nc));
}

// Extract 24 bits of background RGB from 'n', split into subcomponents.
static inline unsigned
ncplane_bg_rgb(const struct ncplane* n, unsigned* r, unsigned* g, unsigned* b){
  return channels_bg_rgb(ncplane_channels(n), r, g, b);
}

int ncplane_set_bg_rgb(struct ncplane* n, int r, int g, int b);
void ncplane_set_bg_rgb_clipped(struct ncplane* n, int r, int g, int b);
int ncplane_set_bg(struct ncplane* n, unsigned channel);
void ncplane_set_bg_default(struct ncplane* n);
int ncplane_set_bg_palindex(struct ncplane* n, int idx);
int ncplane_set_bg_alpha(struct ncplane* n, int alpha);
\end{minted}
\caption{Manipulating a plane's active background channel.}
\label{listing:planebg}
\end{listing}

\begin{listing}[!htbp]
\begin{minted}{C}
// Set the specified style bits for the ncplane 'n', whether they're actively supported or not.
void ncplane_styles_set(struct ncplane* n, unsigned stylebits);

// Add the specified styles to the ncplane's existing spec.
void ncplane_styles_on(struct ncplane* n, unsigned stylebits);

// Remove the specified styles from the ncplane's existing spec.
void ncplane_styles_off(struct ncplane* n, unsigned stylebits);

// Return the current styling for this ncplane.
unsigned ncplane_styles(const struct ncplane* n);
\end{minted}
\caption{Manipulating a plane's active attributes.}
\label{listing:planeattr}
\end{listing}

During the course of \texttt{notcurses\_render()}, the plane is examined at
all cells intersecting with unsolved coordinates (see~\ref{sec:rendering}).
Whenever the EGC at a cell is the null EGC (a \texttt{gcluster} value of 0;
recall that this is the default value), the plane's base cell is instead
considered for rendering purposes. This applies to glyph, attribute, and
colors---there is not yet any means to make multiple cells in a plane glyph-transparent
with different colors\footnote{See \url{https://github.com/dankamongmen/notcurses/issues/395}.}.

\begin{listing}[!htbp]
\begin{minted}{C}
// Set the ncplane's base cell to this cell. It will be used for purposes of rendering anywhere that the ncplane's
// gcluster is 0. Erasing the ncplane does not reset the base cell; this function must be called with a zero 'c'.
int ncplane_set_base_cell(struct ncplane* ncp, const cell* c);

// Set the ncplane's base cell to this cell. It will be used for purposes of
// rendering anywhere that the ncplane's gcluster is 0. Erasing the ncplane
// does not reset the base cell; this function must be called with an empty
// 'egc'. 'egc' must be a single extended grapheme cluster.
int ncplane_set_base(struct ncplane* ncp, uint64_t channels, uint32_t attrword, const char* egc);

// Extract the ncplane's base cell into 'c'. The reference is invalidated if 'ncp' is destroyed.
int ncplane_base(struct ncplane* ncp, cell* c);
\end{minted}
\caption{Manipulating a plane's base cell.}
\end{listing}

\textbf{FIXME FIXME...userptr...}

\begin{listing}[!htbp]
\begin{minted}{C}
// Alignment within the ncplane. Left/right-justified, or centered.
typedef enum {
  NCALIGN_LEFT,
  NCALIGN_CENTER,
  NCALIGN_RIGHT,
} ncalign_e;

// Return the column at which 'c' cols ought start in order to be aligned
// according to 'align' within ncplane 'n'. Returns INT_MAX on invalid 'align'.
// Undefined behavior on negative 'c'.
static inline int
ncplane_align(const struct ncplane* n, ncalign_e align, int c){
  if(align == NCALIGN_LEFT){
    return 0;
  }
  int cols = ncplane_dim_x(n);
  if(align == NCALIGN_CENTER){
    return (cols - c) / 2;
  }else if(align == NCALIGN_RIGHT){
    return cols - c;
  }
  return INT_MAX;
}
\end{minted}
\caption{Aligning output within a plane.}
\end{listing}

Sometimes you'll want to destroy all content in the plane, reinitializing
its framebuffer and base cell without changing the geometry. \texttt{ncplane\_erase()}
allows you to do this in one fell swoop, with the added bonus functionality
of resetting the associated egcpool. A freshly-reset egcpool can be much faster
than one which has been heavily used, requiring a search to find suitable free
space. The state of the framebuffer is exactly as it was when the plane was
created---all cells hold the null EGC, all attributes are 0, and all colors
are defaults. All cells associated with this plane are invalidated, so be
sure you're not holding onto any.
\begin{listing}[!htbp]
\begin{minted}{C}
void ncplane_erase(struct ncplane* n);
\end{minted}
\caption{\texttt{ncplane\_erase()} resets the plane's content and egcpool.}
\end{listing}

\subsection{Cells}
\label{sec:cells}
Each coordinate of an plane corresponds to a \texttt{cell}. The cell definition
is exposed to the application, though it should not generally be directly
manipulated. A multicolumn cell (a cell containing an EGC of $n$ columns where
$n>1$) overrides the $n-1$ following cells. Since there are always a fixed
number of cells, this means that the overridden cells are skipped during
rendering, as well as being zeroed out at the time the multicolumn EGC is
written to the cell.
\begin{listing}[!htbp]
\begin{minted}{C}
typedef struct cell {
  // These 32 bits are either a single-byte, single-character grapheme cluster (values 0â€“0x7f), or
  // an offset into a per-ncplane attached pool of varying-length UTF-8 grapheme clusters.
  uint32_t gcluster;          // 4B -> 4B
  // NCSTYLE_* attributes (16 bits) + 8 foreground palette index bits + 8 background palette index
  // bits. palette index bits are used only if the corresponding default color bit *is not* set,
  // and the corresponding palette index bit *is* set.
  uint32_t attrword;          // + 4B -> 8B
  // (channels & 0x8000000000000000ull): left half of wide character
  // (channels & 0x4000000000000000ull): foreground is *not* "default color"
  // (channels & 0x3000000000000000ull): foreground alpha (2 bits)
  // (channels & 0x0800000000000000ull): foreground uses palette index
  // (channels & 0x0700000000000000ull): reserved, must be 0
  // (channels & 0x00ffffff00000000ull): foreground in 3x8 RGB (rrggbb)
  // (channels & 0x0000000080000000ull): right half of wide character
  // (channels & 0x0000000040000000ull): background is *not* "default color"
  // (channels & 0x0000000030000000ull): background alpha (2 bits)
  // (channels & 0x0000000008000000ull): background uses palette index
  // (channels & 0x0000000007000000ull): reserved, must be 0
  // (channels & 0x0000000000ffffffull): background in 3x8 RGB (rrggbb)
  uint64_t channels;          // + 8B == 16B
} cell;
\end{minted}
\caption{The \texttt{cell} definition.}
\end{listing}
The \texttt{gcluster} field is a 32-bit number. If the value is less than 128,
it directly specifies its UTF-8 encoded character. Since Unicode's first 128
values are taken directly from ASCII, this means the entirety of ASCII can be
represented in-line. If the value is greater than or equal to 128, it is a
bias-128 index into the plane's associated egcpool. Since egcpools are per-plane,
this implies that it is unsafe to blindly copy a cell from one plane to another.

Applications generally need not work directly with cells, though sometimes it
is easiest to do so. The usual reason for working with a cell is either to set
all three properies of output at once (glyph, attributes, and colors), or to
receive all three properties at once when retrieving a coordinate's data.

As further discussed in Chapter~\ref{sec:channels}, the \texttt{channels}
variable is a 64-bit field packing together a number of properties. The high
32 bits apply to the foreground, and the low 32 bits to the background. They
can be set and queried as a channel (Listing~\ref{listing:cellchannels}).

\begin{listing}[!htbp]
\begin{minted}{C}
// Extract the 32-bit background channel from a cell.
static inline unsigned cell_bchannel(const cell* cl){
  return channels_bchannel(cl->channels);
}

// Extract the 32-bit foreground channel from a cell.
static inline unsigned cell_fchannel(const cell* cl){
  return channels_fchannel(cl->channels);
}

// Set the 32-bit background channel of a cell.
static inline uint64_t cell_set_bchannel(cell* cl, uint32_t channel){
  return channels_set_bchannel(&cl->channels, channel);
}

// Set the 32-bit foreground channel of a cell.
static inline uint64_t cell_set_fchannel(cell* cl, uint32_t channel){
  return channels_set_fchannel(&cl->channels, channel);
}
\end{minted}
\caption{Modifying \texttt{cell} channels.}
\label{listing:cellchannels}
\end{listing}

RGB values consume 24 bits of each channel, 75\% of the 64 bits in \texttt{channels}.
RGB values can be blended, clipped, and otherwise dealt with arithmetically.

\begin{listing}[!htbp]
\begin{minted}{C}
// do not pass palette-indexed channels!
static inline uint64_t cell_blend_fchannel(cell* cl, unsigned channel, unsigned* blends){
  return cell_set_fchannel(cl, channels_blend(cell_fchannel(cl), channel, blends));
}

// Extract 24 bits of foreground RGB from 'cell', shifted to LSBs.
static inline unsigned cell_fg(const cell* cl){
  return channels_fg(cl->channels);
}

// Extract 2 bits of foreground alpha from 'cell', shifted to LSBs.
static inline unsigned cell_fg_alpha(const cell* cl){
  return channels_fg_alpha(cl->channels);
}

// Extract 24 bits of foreground RGB from 'cell', split into components.
static inline unsigned cell_fg_rgb(const cell* cl, unsigned* r, unsigned* g, unsigned* b){
  return channels_fg_rgb(cl->channels, r, g, b);
}

// Set the r, g, and b cell for the foreground component of this 64-bit
// 'cell' variable, and mark it as not using the default color.
static inline int cell_set_fg_rgb(cell* cl, int r, int g, int b){
  return channels_set_fg_rgb(&cl->channels, r, g, b);
}

// Same, but clipped to [0..255].
static inline void cell_set_fg_rgb_clipped(cell* cl, int r, int g, int b){
  channels_set_fg_rgb_clipped(&cl->channels, r, g, b);
}

// Same, but with an assembled 24-bit RGB value.
static inline int cell_set_fg(cell* c, uint32_t channel){
  return channels_set_fg(&c->channels, channel);
}
\end{minted}
\caption{\texttt{cell} foreground RGBA functionality.}
\label{listing:cellrgbfg}
\end{listing}

\begin{listing}[!htbp]
\begin{minted}{C}
static inline uint64_t cell_blend_bchannel(cell* cl, unsigned channel, unsigned* blends){
  return cell_set_bchannel(cl, channels_blend(cell_bchannel(cl), channel, blends));
}

// Extract 24 bits of background RGB from 'cell', shifted to LSBs.
static inline unsigned cell_bg(const cell* cl){
  return channels_bg(cl->channels);
}

// Extract 2 bits of background alpha from 'cell', shifted to LSBs.
static inline unsigned cell_bg_alpha(const cell* cl){
  return channels_bg_alpha(cl->channels);
}

// Extract 24 bits of background RGB from 'cell', split into components.
static inline unsigned cell_bg_rgb(const cell* cl, unsigned* r, unsigned* g, unsigned* b){
  return channels_bg_rgb(cl->channels, r, g, b);
}

// Set the r, g, and b cell for the background component of this 64-bit
// 'cell' variable, and mark it as not using the default color.
static inline int cell_set_bg_rgb(cell* cl, int r, int g, int b){
  return channels_set_bg_rgb(&cl->channels, r, g, b);
}

// Same, but clipped to [0..255].
static inline void cell_set_bg_rgb_clipped(cell* cl, int r, int g, int b){
  channels_set_bg_rgb_clipped(&cl->channels, r, g, b);
}

// Same, but with an assembled 24-bit RGB value.
static inline int cell_set_bg(cell* c, uint32_t channel){
  return channels_set_bg(&c->channels, channel);
}
\end{minted}
\caption{\texttt{cell} background RGBA functionality.}
\label{listing:cellrgbbg}
\end{listing}

It is also possible to make use of palette-indexed color (recall that the size
of the palette can be acquired with \texttt{notcurses\_palette\_size()}).
Palette-indexed color requires much less bandwidth than pure RGB (indeed, work
is underway to emit palette-indexed rasterization even when RGB has been
provided---see \url{https://github.com/dankamongmen/notcurses/issues/371}),
and allows for finer control on terminals which don't faithfully implement RGB
DirectColor. The terminal palette can be manually reprogrammed with the
palette256 API (see Chapter~\ref{list:palette256}).

\begin{listing}[!htbp]
\begin{minted}{C}
// Set the cell's foreground palette index, set the foreground palette index
// bit, set it foreground-opaque, and clear the foreground default color bit.
static inline int cell_set_fg_palindex(cell* cl, int idx){
  if(idx < 0 || idx >= NCPALETTESIZE){
    return -1;
  }
  cl->channels |= CELL_FGDEFAULT_MASK;
  cl->channels |= CELL_FG_PALETTE;
  cl->channels &= ~(CELL_ALPHA_MASK << 32u);
  cl->attrword &= 0xffff00ff;
  cl->attrword |= (idx << 8u);
  return 0;
}

static inline unsigned cell_fg_palindex(const cell* cl){
  return (cl->attrword & 0x0000ff00) >> 8u;
}

// Set the cell's background palette index, set the background palette index
// bit, set it background-opaque, and clear the background default color bit.
static inline int cell_set_bg_palindex(cell* cl, int idx){
  if(idx < 0 || idx >= NCPALETTESIZE){
    return -1;
  }
  cl->channels |= CELL_BGDEFAULT_MASK;
  cl->channels |= CELL_BG_PALETTE;
  cl->channels &= ~CELL_ALPHA_MASK;
  cl->attrword &= 0xffffff00;
  cl->attrword |= idx;
  return 0;
}

static inline unsigned cell_bg_palindex(const cell* cl){
  return cl->attrword & 0x000000ff;
}

static inline bool cell_fg_palindex_p(const cell* cl){
  return channels_fg_palindex_p(cl->channels);
}

static inline bool cell_bg_palindex_p(const cell* cl){
  return channels_bg_palindex_p(cl->channels);
}
\end{minted}
\caption{\texttt{cell} palette-indexed color functionality.}
\label{listing:cellpalette}
\end{listing}

Finally, the default fore- and/or background color can be used, and is indeed
the default. Default colors can't be blended. Some terminals can be configured
to use a transparent background. Only in cells using the default background
color can this effect be seen.

\begin{listing}[!htbp]
\begin{minted}{C}
// Is the background using the "default background color"? The "default background color"
// must generally be used to take advantage of terminal-effected transparency.
static inline bool cell_bg_default_p(const cell* cl){
  return channels_bg_default_p(cl->channels);
}

// Is the foreground using the "default foreground color"?
static inline bool cell_fg_default_p(const cell* cl){
  return channels_fg_default_p(cl->channels);
}
\end{minted}
\caption{\texttt{cell} default color functionality.}
\end{listing}

\subsection{egcpools}
\label{sec:egcpools}
Each plane is backed by an \texttt{egcpool} structure. Any cell requiring more
than a single byte to encode its EGC will write the EGC to the egcpool, and
store a byte-granular index into the actual \texttt{gcluster} field of the
\texttt{cell}. The first 128 UTF-8 characters are stored directly, and thus
any \texttt{gcluster} value greater than or equal to 128 is actually a
biased\footnote{128-biased, i.e. \texttt{gcluster} is the offset + 128.}
index into the pool. The pool can grow as large as $2^{25}$ bytes (32 MiB).

\subsection{Alpha blending and plane transparency}
\label{sec:alpha}
\textbf{FIXME FIXME FIXME}

\subsection{Manual palette-indexed color}
\label{sec:palettes}
While it shouldn't ever be necessary, some algorithms are more easily expressed
using palette-indexed color. Functions for manually manipulating the palette
are available when supported by the terminal (as advertised by the ``ccc''
terminfo capability).
\begin{listing}[!htbp]
\begin{minted}{C}

typedef struct palette256 {
  uint32_t chans[NCPALETTESIZE]; // We store the RGB values as a regular ol' channel
} palette256;

// Create a new palette store. It will be initialized with notcurses's best
// knowledge of the currently configured palette.
palette256* palette256_new(struct notcurses* nc);

// Attempt to configure the terminal with the provided palette 'p'. Does not
// transfer ownership of 'p'; palette256_free() can still be called.
int palette256_use(struct notcurses* nc, const palette256* p);

// Manipulate entries in the palette store 'p'. These are *not* locked.
static inline int palette256_set_rgb(palette256* p, int idx, int r, int g, int b){
  if(idx < 0 || (size_t)idx > sizeof(p->chans) / sizeof(*p->chans)){
    return -1;
  }
  return channel_set_rgb(&p->chans[idx], r, g, b);
}

static inline int palette256_set(palette256* p, int idx, unsigned rgb){
  if(idx < 0 || (size_t)idx > sizeof(p->chans) / sizeof(*p->chans)){
    return -1;
  }
  return channel_set(&p->chans[idx], rgb);
}

static inline int palette256_get_rgb(const palette256* p, int idx, unsigned* restrict r,
                                     unsigned* restrict g, unsigned* restrict b);
  if(idx < 0 || (size_t)idx > sizeof(p->chans) / sizeof(*p->chans)){
    return -1;
  }
  return channel_rgb(p->chans[idx], r, g, b);
}

// Free the palette store 'p'.
void palette256_free(palette256* p);

// Convert the plane's content to greyscale.
void ncplane_greyscale(struct ncplane* n);
\end{minted}
\caption{The palette256 API facilitates manual palette programming.}
\label{list:palette256}
\end{listing}
